// Generated by CoffeeScript 1.6.1
var ACTIVATE, ANALOGSTICK, ASSETS, BEGINNINGTIME, BGSCENE, BGSCENE_SUB1, BGSCENE_SUB2, BOX, CAMERA, COLLADA, CONTROL, CUBE, CYLINDER, DEBUGSCENE, DEG, DEVICE_HEIGHT, DEVICE_WIDTH, DYNAMIC_BOX, DYNAMIC_CIRCLE, EXMAP, GAMESCENE, GAMESCENE_SUB1, GAMESCENE_SUB2, GLOBAL, GRAVITY_X, GRAVITY_Y, HORIZONTAL, JSLog, LABEL, LAPSEDTIME, LIGHT, MAP, MAXSCENE, MOTION_ACCEL, MOTION_GRAVITY, MOTION_ROTATE, OCULUS, PADAXES, PADBUTTONS, PLANE, PRIMITIVE, RAD, RENDERER, SCREEN_HEIGHT, SCREEN_WIDTH, SPHERE, SPRITE, STATIC_BOX, STATIC_CIRCLE, SURFACE, TOPSCENE, TORUS, VERTICAL, WEBGL, WEBGLSCENE, addObject, box2dworld, core, createVirtualGamepad, debugclear, debugwrite, dispDefaultBrowserCheck, dispVirtualGamepad, gamepadProcedure, gamepaddisconnected, getBounds, getCookie, getKeyDirection, getObject, isWebGL, nop, pauseGame, pauseSound, playSound, rand, removeObject, resumeGame, resumeSound, rootScene, rootScene3d, setCookie, setMotionObj, setSoundLoudness, sprintf, stopSound, uniqueID, _DEBUGLABEL, _GAMEPADPROCEDURE_, _GAMEPADSINFO, _SYSTEMSCENE, _VGAMEPADCONTROL, _browserMajorClass, _defaultbrowser, _frame, _getNullObject, _main, _objects, _originObject, _scenes, _stationary, _useragent, _vanalogpad, _vgamebutton, _vgamepadcontrol,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

_originObject = (function() {

  function _originObject() {
    this.active = false;
  }

  return _originObject;

})();

_stationary = (function() {

  function _stationary(initparam) {
    var _this = this;
    this._processnumber = 0;
    this._waittime = 0.0;
    this._dispframe = 0;
    this._endflag = false;
    this._returnflag = false;
    this._autoRemove = false;
    this._animTime = LAPSEDTIME * 1000;
    this.sprite = initparam['motionsprite'];
    if ((this.sprite != null)) {
      this._type = initparam['_type'];
      this._xback = this.x = initparam['x'];
      this._yback = this.y = initparam['y'];
      this.z = initparam['z'];
      this._xsback = this.xs = initparam['xs'];
      this._ysback = this.ys = initparam['ys'];
      this.zs = initparam['zs'];
      this.visible = initparam['visible'];
      this.scaleX = initparam['scaleX'];
      this.scaleY = initparam['scaleY'];
      this.scaleZ = initparam['scaleZ'];
      this.gravity = initparam['gravity'];
      this.intersectFlag = initparam['intersectFlag'];
      this.width = initparam['width'];
      this.height = initparam['height'];
      this.depth = initparam['depth'];
      this.image = initparam['image'];
      this.size = initparam['size'];
      this.radius = initparam['radius'];
      this.radius2 = initparam['radius2'];
      this._diffx = initparam['diffx'];
      this._diffy = initparam['diffy'];
      this.animlist = initparam['animlist'];
      this.animnum = initparam['animnum'];
      this.opacity = initparam['opacity'];
      this.rotation = initparam['rotation'];
      this.fontsize = initparam['fontsize'];
      this.color = initparam['color'];
      this.labeltext = initparam['labeltext'];
      this.textalign = initparam['textalign'];
      this.parent = initparam['parent'];
      this.active = initparam['active'];
      this.collider = initparam['collider'];
      this._offsetx = initparam['offsetx'];
      this._offsety = initparam['offsety'];
      this.animnum_back = this.animnum;
      if (this.collider == null) {
        this.collider = this;
      }
      this.lastvisible = this.visible;
      this.sprite.scaleX = this.scaleX;
      this.sprite.scaleY = this.scaleY;
      this.sprite.scaleZ = this.scaleZ;
      this.sprite.alpha = this.opacity;
      this.sprite.setInteractive(true);
      this.sprite.onpointingstart = function(e) {
        var pos;
        pos = {
          x: e.app.pointing.x,
          y: e.app.pointing.y
        };
        if (typeof _this.touchesBegan === 'function' && _this.visible) {
          return _this.touchesBegan(pos);
        }
      };
      this.sprite.onpointingmove = function(e) {
        var pos;
        pos = {
          x: e.app.pointing.x,
          y: e.app.pointing.y
        };
        if (typeof _this.touchesMoved === 'function' && _this.visible) {
          return _this.touchesMoved(pos);
        }
      };
      this.sprite.onpointingend = function(e) {
        var pos;
        pos = {
          x: e.app.pointing.x,
          y: e.app.pointing.y
        };
        if (typeof _this.touchesEnded === 'function' && _this.visible) {
          return _this.touchesEnded(pos);
        }
      };
      this.sprite.onpointingcancel = function(e) {
        var pos;
        pos = {
          x: e.app.pointing.x,
          y: e.app.pointing.y
        };
        if (typeof _this.touchesCanceled === 'function' && _this.visible) {
          return _this.touchesCanceled(pos);
        }
      };
      this.intersectFlag = true;
      this.sprite.visible = false;
      this.sprite.x = Math.floor(this.x);
      this.sprite.y = Math.floor(this.y - this.z);
    }
  }

  _stationary.prototype.destructor = function() {};

  _stationary.prototype.behavior = function() {
    var animpattern, animtime, animtmp;
    if ((this.sprite != null)) {
      switch (this._type) {
        case SPRITE:
          this.sprite.x = Math.floor(this.x);
          this.sprite.y = Math.floor(this.y - this.z);
          this.ys += this.gravity;
          this.x += this.xs;
          this.y += this.ys;
          this.z += this.zs;
          if (this.rotation > 359) {
            this.rotation = this.rotation % 360;
          }
          this.sprite.rotation = this.rotation;
          if ((this.collider != null) && (this.collider.sprite != null)) {
            if (this.collider._uniqueID !== this._uniqueID) {
              this.collider.sprite.visible = DEBUG;
              this.collider.visible = DEBUG;
              this.collider.opacity = DEBUG ? 0.5 : 1.0;
              this.collider._xback = this.collider.x = this.sprite.x - this.collider._offsetx;
              this.collider._yback = this.collider.y = this.sprite.y + this.collider._offsety;
            }
          }
          if (this.opacity !== this.sprite.alpha) {
            if (this.sprite.alpha === this.opacity_back) {
              this.sprite.alpha = this.opacity;
            } else {
              this.opacity = this.sprite.alpha;
            }
          }
          this.opacity_back = this.sprite.alpha;
          this.sprite.visible = this.visible;
          this.sprite.scaleX = this.scaleX;
          this.sprite.scaleY = this.scaleY;
          this.sprite.width = this.width;
          this.sprite.height = this.height;
          if (this._type === SPRITE && (this.animlist != null)) {
            if (this.animnum_back !== this.animnum) {
              this._dispframe = 0;
              this.animnum_back = this.animnum;
            }
            animtmp = this.animlist[this.animnum];
            animtime = animtmp[0];
            animpattern = animtmp[1];
            if (LAPSEDTIME * 1000 > this._animTime + animtime) {
              this.sprite.frameIndex = animpattern[this._dispframe];
              this._animTime = LAPSEDTIME * 1000;
              this._dispframe++;
              if (this._dispframe >= animpattern.length) {
                if (this._endflag === true) {
                  this._endflag = false;
                  removeObject(this);
                  return;
                } else if (this._returnflag === true) {
                  this._returnflag = false;
                  this.animnum = this._beforeAnimnum;
                  this._dispframe = 0;
                } else {
                  this._dispframe = 0;
                }
              }
            }
          }
          break;
        case LABEL:
          this.sprite.x = Math.floor(this.x);
          this.sprite.y = Math.floor(this.y - this.z);
          this.x += this.xs;
          this.y += this.ys;
          this.z += this.zs;
          if (this.opacity !== this.sprite.alpha) {
            if (this.sprite.alpha === this.opacity_back) {
              this.sprite.alpha = this.opacity;
            } else {
              this.opacity = this.sprite.alpha;
            }
          }
          this.opacity_back = this.sprite.alpha;
          this.sprite.visible = this.visible;
          this.sprite.scaleX = this.scaleX;
          this.sprite.scaleY = this.scaleY;
          this.sprite.width = this.width;
          this.sprite.height = this.height;
          this.sprite.fontSize = this.fontsize;
          this.sprite.fontFamily = 'Arial';
          this.sprite.fillStyle = this.color;
          this.sprite.text = this.labeltext;
          this.sprite.align = this.textalign;
          break;
        case PRIMITIVE:
        case COLLADA:
          if (this.lastvisible !== this.visible) {
            if (this.visible) {
              rootScene3d.addChild(this.sprite);
            } else {
              rootScene3d.removeChild(this.sprite);
            }
            this.lastvisible = this.visible;
          }
          this.sprite.x = this.x;
          this.sprite.y = this.y;
          this.sprite.z = this.z;
          if (this.scaleX !== this.sprite.scaleX) {
            this.sprite.scaleX = this.scaleX;
          }
          if (this.scaleY !== this.sprite.scaleY) {
            this.sprite.scaleY = this.scaleY;
          }
          if (this.scaleZ !== this.sprite.scaleZ) {
            this.sprite.scaleZ = this.scaleZ;
          }
          this.ys += this.gravity;
          this.x += this.xs;
          this.y += this.ys;
          this.z += this.zs;
          break;
        case MAP:
          this.sprite.x = Math.floor(this.x - this._diffx);
          this.sprite.y = Math.floor(this.y - this._diffy);
          this.x += this.xs;
          this.y += this.ys;
          if (this.opacity !== this.sprite.alpha) {
            if (this.opacity < 0.0) {
              this.opacity = 0.0;
            }
            if (this.opacity > 1.0) {
              this.opacity = 1.0;
            }
            if (this.sprite.alpha === this.opacity_back) {
              this.sprite.alpha = this.opacity;
            } else {
              this.opacity = this.sprite.alpha;
            }
          }
          this.opacity_back = this.sprite.alpha;
          this.sprite.visible = this.visible;
      }
    }
    if (this._waittime > 0 && LAPSEDTIME > this._waittime) {
      this._waittime = 0;
      return this._processnumber = this._nextprocessnum;
    }
  };

  _stationary.prototype.setQuaternion = function(v, angle) {
    switch (v) {
      case 0:
        return this.sprite.rotationSet(new Quat(1, 0, 0, angle * RAD));
      case 1:
        return this.sprite.rotationSet(new Quat(0, 1, 0, angle * RAD));
      case 2:
        return this.sprite.rotationSet(new Quat(0, 0, 1, angle * RAD));
    }
  };

  _stationary.prototype.applyQuaternion = function(v, angle) {
    switch (v) {
      case 0:
        return this.sprite.rotationApply(new Quat(1, 0, 0, angle * RAD));
      case 1:
        return this.sprite.rotationApply(new Quat(0, 1, 0, angle * RAD));
      case 2:
        return this.sprite.rotationApply(new Quat(0, 0, 1, angle * RAD));
    }
  };

  _stationary.prototype.setTexture = function(image) {
    var texture;
    if (this._type !== PRIMITIVE && this._type !== COLLADA) {
      return;
    }
    texture = MEDIALIST[image];
    return this.sprite.texture = new Texture(texture);
  };

  _stationary.prototype.touchesBegan = function(e) {};

  _stationary.prototype.touchesMoved = function(e) {};

  _stationary.prototype.touchesEnded = function(e) {};

  _stationary.prototype.touchesCanceled = function(e) {};

  _stationary.prototype.nextjob = function() {
    return this._processnumber++;
  };

  _stationary.prototype.waitjob = function(wtime) {
    this._waittime = parseFloat(LAPSEDTIME) + wtime;
    this._nextprocessnum = this._processnumber + 1;
    return this._processnumber = -1;
  };

  _stationary.prototype.setProcessNumber = function(num) {
    return this._processnumber = num;
  };

  _stationary.prototype.isWithIn = function(motionObj, range) {
    if (range == null) {
      range = -1;
    }
    return false;
  };

  _stationary.prototype.isIntersect = function(motionObj) {
    var ret;
    if (this._type === SPRITE) {
      if ((motionObj == null) || (motionObj.collider == null) || (motionObj.collider.sprite == null) || (this.collider == null) || (this.collider.sprite == null)) {
        ret = false;
      } else if (this.intersectFlag === true && motionObj.intersectFlag === true) {
        ret = this.collider.sprite.isHitElement(motionObj.collider.sprite);
      } else {
        ret = false;
      }
    }
    return ret;
  };

  _stationary.prototype.isCollision = function(x, y) {
    var ret;
    if (this._type === MAP) {
      return ret = this.sprite.isHitPoint(x, y);
    } else {
      return ret = false;
    }
  };

  _stationary.prototype.setAnimationToRemove = function(animnum) {
    this.animnum = animnum;
    this._dispframe = 0;
    return this._endflag = true;
  };

  _stationary.prototype.setAnimationToOnce = function(animnum, animnum2) {
    this._beforeAnimnum = animnum2;
    this.animnum = animnum;
    this._dispframe = 0;
    return this._returnflag = true;
  };

  _stationary.prototype.setModel = function(name) {
    var model;
    model = MEDIALIST[name];
    return this.set(core.assets[model]);
  };

  _stationary.prototype.addTarget = function(func) {
    var _this = this;
    return this.sprite.addEventListener('touchstart', function(e) {
      return func(e.app.pointing.x, e.app.pointing.y);
    });
  };

  _stationary.prototype.spriteRotation = function(ang) {
    return this.sprite.rotate(ang * DEG);
  };

  _stationary.prototype.fadeIn = function(time) {
    this.sprite.tweener.to({
      alpha: 1.0
    }, time);
    return this;
  };

  _stationary.prototype.fadeOut = function(time) {
    this.sprite.tweener.to({
      alpha: 0.0
    }, time);
    return this;
  };

  _stationary.prototype.loop = function() {};

  _stationary.prototype.clear = function() {
    this.sprite.tweener.clear();
    return this;
  };

  _stationary.prototype.moveTo = function(x, y, time, easing) {
    if (easing == null) {
      easing = "easeOutQuad";
    }
    this.sprite.tweener.to({
      x: x,
      y: y
    }, time, easing);
    return this;
  };

  _stationary.prototype.moveBy = function(x, y, time, easing) {
    if (easing == null) {
      easing = "easeOutQuad";
    }
    this.sprite.tweener.by({
      x: x,
      y: y
    }, time, easing);
    return this;
  };

  _stationary.prototype.delay = function(time) {
    this.sprite.tweener.wait(time);
    return this;
  };

  _stationary.prototype.then = function(func) {
    this.sprite.tweener.call(func);
    return this;
  };

  return _stationary;

})();

_vanalogpad = (function(_super) {

  __extends(_vanalogpad, _super);

  function _vanalogpad(initparam) {
    _vanalogpad.__super__.constructor.call(this, initparam);
    this.input = [];
    this.input.axes = [];
    this.input.axes.up = false;
    this.input.axes.down = false;
    this.input.axes.left = false;
    this.input.axes.right = false;
    this.radius = parseFloat(this.width * this.scaleX / 2);
    this.arclength = 0;
  }

  _vanalogpad.prototype.destructor = function() {
    _vanalogpad.__super__.destructor.call(this);
    return removeObject(this.cursor);
  };

  _vanalogpad.prototype.behavior = function() {
    _vanalogpad.__super__.behavior.call(this);
    switch (this._processnumber) {
      case 0:
        return nop();
    }
  };

  _vanalogpad.prototype.touchesBegan = function(pos) {
    _vanalogpad.__super__.touchesBegan.call(this, pos);
    return this.movePad(pos);
  };

  _vanalogpad.prototype.touchesMoved = function(pos) {
    _vanalogpad.__super__.touchesMoved.call(this, pos);
    return this.movePad(pos);
  };

  _vanalogpad.prototype.touchesEnded = function(pos) {
    _vanalogpad.__super__.touchesEnded.call(this, pos);
    if ((this.cursor != null)) {
      this.cursor.x = this.x;
    }
    if ((this.cursor != null)) {
      this.cursor.y = this.y;
    }
    this.input.axes.up = false;
    this.input.axes.down = false;
    this.input.axes.left = false;
    this.input.axes.right = false;
    ANALOGSTICK[0][HORIZONTAL] = 0.0;
    return ANALOGSTICK[0][VERTICAL] = 0.0;
  };

  _vanalogpad.prototype.touchesCanceled = function(pos) {
    _vanalogpad.__super__.touchesCanceled.call(this, pos);
    if ((this.cursor != null)) {
      this.cursor.x = this.x;
    }
    if ((this.cursor != null)) {
      this.cursor.y = this.y;
    }
    this.input.axes.up = false;
    this.input.axes.down = false;
    this.input.axes.left = false;
    this.input.axes.right = false;
    ANALOGSTICK[0][HORIZONTAL] = 0.0;
    return ANALOGSTICK[0][VERTICAL] = 0.0;
  };

  _vanalogpad.prototype.movePad = function(pos) {
    var h, mx, my, v;
    this.alength = pos.x - this.x;
    this.blength = pos.y - this.y;
    if (this.alength > 0) {
      this.angle = 90 - (Math.atan(this.blength / this.alength) * DEG);
    } else {
      this.angle = 270 - (Math.atan(this.blength / this.alength) * DEG);
    }
    this.angle -= 90;
    if (this.angle < 0) {
      this.angle = 360 + this.angle;
    }
    this.arclength = Math.abs(Math.sqrt(this.alength * this.alength + this.blength * this.blength));
    if (this.arclength > this.radius) {
      this.arclength = this.radius;
      mx = this.x + Math.cos((360 - this.angle) * RAD) * (50 * this.scaleX);
      my = this.y + Math.sin((360 - this.angle) * RAD) * (50 * this.scaleX);
    } else {
      mx = pos.x;
      my = pos.y;
    }
    if ((this.cursor != null)) {
      this.cursor.x = mx;
    }
    if ((this.cursor != null)) {
      this.cursor.y = my;
    }
    h = this.alength / this.radius;
    if (h > 1.0) {
      h = 1.0;
    }
    if (h < -1.0) {
      h = -1.0;
    }
    v = this.blength / this.radius;
    if (v > 1.0) {
      v = 1.0;
    }
    if (v < -1.0) {
      v = -1.0;
    }
    ANALOGSTICK[0][HORIZONTAL] = h;
    ANALOGSTICK[0][VERTICAL] = v;
    this.input.axes.up = v < -0.3 ? true : false;
    this.input.axes.down = v > 0.3 ? true : false;
    this.input.axes.left = h < -0.3 ? true : false;
    return this.input.axes.right = h > 0.3 ? true : false;
  };

  return _vanalogpad;

})(_stationary);

_vgamebutton = (function(_super) {

  __extends(_vgamebutton, _super);

  function _vgamebutton(initparam) {
    _vgamebutton.__super__.constructor.call(this, initparam);
    this.push = false;
    this.visible = true;
  }

  _vgamebutton.prototype.destructor = function() {
    return _vgamebutton.__super__.destructor.call(this);
  };

  _vgamebutton.prototype.behavior = function() {
    _vgamebutton.__super__.behavior.call(this);
    switch (this._processnumber) {
      case 0:
        return nop();
    }
  };

  _vgamebutton.prototype.touchesBegan = function(pos) {
    _vgamebutton.__super__.touchesBegan.call(this, pos);
    this.push = true;
    return this.animnum = 1;
  };

  _vgamebutton.prototype.touchesEnded = function(pos) {
    _vgamebutton.__super__.touchesEnded.call(this, pos);
    this.push = false;
    return this.animnum = 0;
  };

  _vgamebutton.prototype.touchesCanceled = function(pos) {
    _vgamebutton.__super__.touchesCanceled.call(this, pos);
    return this.animnum = 0;
  };

  return _vgamebutton;

})(_stationary);

_vgamepadcontrol = (function(_super) {

  __extends(_vgamepadcontrol, _super);

  function _vgamepadcontrol(initparam) {
    _vgamepadcontrol.__super__.constructor.call(this, initparam);
    this.vgamepad = void 0;
    this.vgamecursor = void 0;
    this.vgamebuttonlist = [];
    this.input = [];
    this.input.axes = [];
    this.input.analog = [];
    this.input.axes.up = false;
    this.input.axes.down = false;
    this.input.axes.left = false;
    this.input.axes.right = false;
    this.input.buttons = [false, false, false, false, false, false];
    this.input.analog[HORIZONTAL] = 0.0;
    this.input.analog[VERTICAL] = 0.0;
  }

  _vgamepadcontrol.prototype.destructor = function() {
    var obj, _i, _len, _ref, _results;
    _vgamepadcontrol.__super__.destructor.call(this);
    if ((this.vgamecursor != null)) {
      removeObject(this.vgamecursor);
    }
    if ((this.vgamepad != null)) {
      removeObject(this.vgamepad);
    }
    _ref = this.vgamebuttonlist;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      obj = _ref[_i];
      if ((obj != null)) {
        _results.push(removeObject(obj));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _vgamepadcontrol.prototype.behavior = function() {
    _vgamepadcontrol.__super__.behavior.call(this);
    switch (this._processnumber) {
      case 0:
        this.input.axes.up = this.vgamepad.input.axes.up;
        this.input.axes.down = this.vgamepad.input.axes.down;
        this.input.axes.left = this.vgamepad.input.axes.left;
        this.input.axes.right = this.vgamepad.input.axes.right;
        if (this.vgamebuttonlist[0]) {
          this.input.buttons[0] = this.vgamebuttonlist[0].push;
        }
        if (this.vgamebuttonlist[1]) {
          this.input.buttons[1] = this.vgamebuttonlist[1].push;
        }
        if (this.vgamebuttonlist[2]) {
          this.input.buttons[2] = this.vgamebuttonlist[2].push;
        }
        if (this.vgamebuttonlist[3]) {
          this.input.buttons[3] = this.vgamebuttonlist[3].push;
        }
        if (this.vgamebuttonlist[4]) {
          this.input.buttons[4] = this.vgamebuttonlist[4].push;
        }
        if (this.vgamebuttonlist[5]) {
          return this.input.buttons[5] = this.vgamebuttonlist[5].push;
        }
    }
  };

  _vgamepadcontrol.prototype.createGamePad = function(param) {
    var analog, button, buttonname, buttonscale, c, coord, i, kind, obj, padname, padname2, scale, visible, x, y, _i, _results;
    if ((param != null)) {
      scale = (param.scale != null) ? param.scale : 1;
      x = (param.x != null) ? param.x : (100 / 2) * scale;
      y = (param.y != null) ? param.y : SCREEN_HEIGHT - ((100 / 2) * scale);
      visible = (param.visible != null) ? param.visible : true;
      kind = (param.kind != null) ? param.kind : 0;
      analog = (param.analog != null) ? param.analog : false;
      button = (param.button != null) ? param.button : 0;
      buttonscale = (param.buttonscale != null) ? param.buttonscale : 1;
      coord = (param.coord != null) ? param.coord : [];
    }
    switch (kind) {
      case 0:
        if (analog) {
          padname = "_apad_w";
          padname2 = "_apad2_w";
        } else {
          padname = "_pad_w";
        }
        buttonname = "_button_w";
        break;
      case 1:
        if (analog) {
          padname = "_apad_b";
          padname2 = "_apad2_b";
        } else {
          padname = "_pad_b";
        }
        buttonname = "_button_b";
    }
    if (analog) {
      this.vgamecursor = addObject({
        image: padname2,
        x: this.x,
        y: this.y,
        width: 40,
        height: 40,
        scaleX: scale,
        scaleY: scale,
        visible: false,
        animlist: [[100, [0]]],
        scene: _SYSTEMSCENE
      });
    }
    this.vgamepad = addObject({
      motionObj: analog ? _vanalogpad : _vdigipad,
      image: padname,
      x: this.x,
      y: this.y,
      width: 100,
      height: 100,
      animlist: [[100, [0]], [100, [1]], [100, [2]]],
      visible: false,
      scaleX: scale,
      scaleY: scale,
      scene: _SYSTEMSCENE
    });
    if ((this.vgamecursor != null)) {
      this.vgamepad.cursor = this.vgamecursor;
    }
    this.vgamepad.visible = visible;
    _results = [];
    for (i = _i = 0; 0 <= button ? _i < button : _i > button; i = 0 <= button ? ++_i : --_i) {
      c = coord[i];
      if (c == null) {
        c = [];
        c[0] = SCREEN_WIDTH - ((64 / 2) * buttonscale);
        c[1] = (64 * buttonscale) * i + (32 * buttonscale);
      }
      obj = addObject({
        image: buttonname,
        motionObj: _vgamebutton,
        width: 64,
        height: 64,
        x: c[0],
        y: c[1],
        visible: false,
        scaleX: buttonscale,
        scaleY: buttonscale,
        animlist: [[100, [0]], [100, [1]]],
        scene: _SYSTEMSCENE
      });
      obj.visible = visible;
      _results.push(this.vgamebuttonlist.push(obj));
    }
    return _results;
  };

  _vgamepadcontrol.prototype.setVisible = function(visible) {
    var obj, _i, _len, _ref, _results;
    this.visible = visible;
    if ((this.vgamecursor != null)) {
      this.vgamecursor.visible = this.visible;
    }
    this.vgamepad.visible = this.visible;
    _ref = this.vgamebuttonlist;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      obj = _ref[_i];
      if ((obj != null)) {
        _results.push(obj.visible = this.visible);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return _vgamepadcontrol;

})(_stationary);

rand = function(n) {
  return parseInt(Math.floor(Math.random() * (n + 1)));
};

JSLog = function() {
  var a, b, data, _i, _len;
  a = arguments[0], b = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (DEBUG === true) {
    for (_i = 0, _len = b.length; _i < _len; _i++) {
      data = b[_i];
      a = a.replace('%@', data);
    }
    return console.log(a);
  }
};

sprintf = function() {
  var a, b, data, _i, _len;
  a = arguments[0], b = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = b.length; _i < _len; _i++) {
    data = b[_i];
    a = a.replace('%@', data);
  }
  return a;
};

uniqueID = function() {
  var S4;
  S4 = function() {
    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
  };
  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
};

getBounds = function() {
  var frame;
  frame = [parseInt(document.documentElement.clientWidth - 1), parseInt(document.documentElement.clientHeight - 1)];
  return frame;
};

getKeyDirection = function() {
  var dir;
  dir = {
    x: 0,
    y: 0
  };
  if (core.input.up) {
    dir['y'] = -1;
  }
  if (core.input.down) {
    dir['y'] = 1;
  }
  if (core.input.right) {
    dir['x'] = 1;
  }
  if (core.input.left) {
    dir['x'] = -1;
  }
  return dir;
};

setCookie = function(name, value, expireValue) {
  if (expireValue == null) {
    expireValue = 1;
  }
  return document.cookie = name + '=' + escape(value) + '; expires=' + expireValue;
};

getCookie = function(name) {
  var allcookies, cookie, i, result, _i, _ref;
  result = [];
  allcookies = document.cookie.split('; ');
  if (allcookies.length > 0) {
    for (i = _i = 0, _ref = allcookies.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      cookie = allcookies[i].split('=');
      result[cookie[0]] = decodeURIComponent(cookie[1]);
    }
  }
  return result[name];
};

isWebGL = function() {
  try {
    return !!window.WebGLRenderingContext && !!document.createElement('canvas').getContext('experimental-webgl');
  } catch (e) {
    return false;
  }
};

nop = function() {};

CONTROL = 0;

SPRITE = 1;

LABEL = 2;

SURFACE = 3;

PRIMITIVE = 4;

COLLADA = 5;

MAP = 6;

EXMAP = 7;

DYNAMIC_BOX = 0;

DYNAMIC_CIRCLE = 1;

STATIC_BOX = 2;

STATIC_CIRCLE = 3;

BOX = 0;

CUBE = 1;

SPHERE = 2;

CYLINDER = 3;

TORUS = 4;

PLANE = 5;

BGSCENE = 0;

BGSCENE_SUB1 = 1;

BGSCENE_SUB2 = 2;

GAMESCENE = 3;

GAMESCENE_SUB1 = 4;

GAMESCENE_SUB2 = 5;

TOPSCENE = 6;

WEBGLSCENE = 7;

_SYSTEMSCENE = 8;

DEBUGSCENE = 9;

MAXSCENE = (DEBUG ? DEBUGSCENE : _SYSTEMSCENE);

RAD = Math.PI / 180.0;

DEG = 180.0 / Math.PI;

GLOBAL = [];

HORIZONTAL = 0;

VERTICAL = 1;

_GAMEPADSINFO = [];

PADBUTTONS = [];

PADBUTTONS[0] = [false, false];

PADAXES = [];

PADAXES[0] = [0, 0];

ANALOGSTICK = [];

ANALOGSTICK[0] = [0, 0, 0, 0];

_VGAMEPADCONTROL = void 0;

if (typeof GRAVITY_X === "undefined" || GRAVITY_X === null) {
  GRAVITY_X = 0.0;
}

if (typeof GRAVITY_Y === "undefined" || GRAVITY_Y === null) {
  GRAVITY_Y = 0.0;
}

MOTION_ACCEL = [
  {
    x: 0,
    y: 0,
    z: 0
  }
];

MOTION_GRAVITY = [
  {
    x: 0,
    y: 0,
    z: 0
  }
];

MOTION_ROTATE = [
  {
    alpha: 0,
    beta: 0,
    gamma: 0
  }
];

_useragent = window.navigator.userAgent.toLowerCase();

if (_useragent.match(/^.*android.*?mobile safari.*$/i) !== null && _useragent.match(/^.*\) chrome.*/i) === null) {
  _defaultbrowser = true;
} else {
  _defaultbrowser = false;
}

if (_useragent.match(/.* firefox\/.*/)) {
  _browserMajorClass = "firefox";
} else if (_useragent.match(/.*version\/.* safari\/.*/)) {
  _browserMajorClass = "safari";
} else if (_useragent.match(/.*chrome\/.* safari\/.*/)) {
  _browserMajorClass = "chrome";
} else {
  _browserMajorClass = "unknown";
}

LAPSEDTIME = 0;

BEGINNINGTIME = parseFloat((new Date) / 1000);

WEBGL = void 0;

OCULUS = void 0;

RENDERER = void 0;

CAMERA = void 0;

LIGHT = void 0;

_frame = getBounds();

DEVICE_WIDTH = _frame[0];

DEVICE_HEIGHT = _frame[1];

if ((typeof SCREEN_WIDTH === "undefined" || SCREEN_WIDTH === null) && (typeof SCREEN_HEIGHT === "undefined" || SCREEN_HEIGHT === null)) {
  SCREEN_WIDTH = DEVICE_WIDTH;
  SCREEN_HEIGHT = DEVICE_HEIGHT;
}

ASSETS = [];

ACTIVATE = true;

_objects = [];

_scenes = [];

_main = null;

_DEBUGLABEL = void 0;

core = void 0;

box2dworld = void 0;

rootScene3d = void 0;

rootScene = void 0;

tm.main(function() {
  var _this = this;
  tm.define("customLoadingScene", {
    superClass: "tm.app.Scene",
    init: function(param) {
      var label;
      this.superInit();
      this.bg = tm.display.Shape().addChildTo(this);
      this.bg.canvas.clearColor("#000000");
      this.bg.setOrigin(0, 0);
      label = tm.display.Label("loading");
      label.x = param.width / 2;
      label.y = param.height / 2;
      label.width = param.width;
      label.align = "center";
      label.baseline = "middle";
      label.fontSize = 24;
      label.setFillStyle("#ffffff");
      label.counter = 0;
      label.update = function(app) {
        if (app.frame % 30 === 0) {
          this.text += ".";
          this.counter += 1;
          if (this.counter > 3) {
            this.counter = 0;
            this.text = "loading";
          }
        }
      };
      label.addChildTo(this.bg);
      this.bg.tweener.clear().fadeIn(100).call((function() {
        var loader;
        if (param.assets) {
          loader = tm.asset.Loader();
          loader.onload = (function() {
            this.bg.tweener.clear().wait(300).fadeOut(300).call((function() {
              var e;
              if (param.nextScene) {
                core.replaceScene(param.nextScene());
              }
              e = tm.event.Event("load");
              this.fire(e);
            }).bind(this));
          }).bind(this);
          loader.onprogress = (function(e) {
            var event;
            event = tm.event.Event("progress");
            event.progress = e.progress;
            this.fire(event);
          }).bind(this);
          loader.load(param.assets);
        }
      }).bind(this));
    }
  });
  tm.define("mainScene", {
    superClass: "tm.app.Scene",
    init: function() {
      var gravity, i, scene, _i, _j;
      this.superInit();
      core.background = BGCOLOR;
      rootScene = this;
      for (i = _i = 0; 0 <= MAXSCENE ? _i <= MAXSCENE : _i >= MAXSCENE; i = 0 <= MAXSCENE ? ++_i : --_i) {
        scene = tm.display.CanvasElement().addChildTo(rootScene);
        _scenes[i] = scene;
      }
      gravity = new Box2D.Common.Math.b2Vec2(GRAVITY_X, GRAVITY_Y);
      box2dworld = new Box2D.Dynamics.b2World(gravity, true);
      if (DEBUG === true) {
        _DEBUGLABEL = new tm.display.Label();
        _DEBUGLABEL.originX = 0;
        _DEBUGLABEL.originY = 0;
        _DEBUGLABEL.x = SCREEN_WIDTH / 2;
        _DEBUGLABEL.y = SCREEN_HEIGHT / 2;
        _DEBUGLABEL.align = "center";
        _scenes[DEBUGSCENE].addChild(_DEBUGLABEL);
      }
      for (i = _j = 0; 0 <= OBJECTNUM ? _j < OBJECTNUM : _j > OBJECTNUM; i = 0 <= OBJECTNUM ? ++_j : --_j) {
        _objects[i] = new _originObject();
      }
      _main = new enforceMain();
    },
    onenterframe: function() {
      var key, num, obj, padobj, _i, _j, _len, _ref, _results;
      if (typeof gamepadProcedure === 'function') {
        _GAMEPADSINFO = gamepadProcedure();
        for (num = _i = 0, _ref = _GAMEPADSINFO.length; 0 <= _ref ? _i < _ref : _i > _ref; num = 0 <= _ref ? ++_i : --_i) {
          if (_GAMEPADSINFO[num] == null) {
            continue;
          }
          padobj = _GAMEPADSINFO[num];
          PADBUTTONS[num] = _GAMEPADSINFO[num].padbuttons;
          PADAXES[num] = _GAMEPADSINFO[num].padaxes;
          ANALOGSTICK[num] = _GAMEPADSINFO[num].analogstick;
        }
      }
      key = core.keyboard;
      if (key.getKey("z") || ((_VGAMEPADCONTROL.input.buttons[0] != null) && _VGAMEPADCONTROL.input.buttons[0])) {
        PADBUTTONS[0][0] = true;
      } else if (_GAMEPADSINFO[0] == null) {
        PADBUTTONS[0][0] = false;
      }
      if (key.getKey("x") || ((_VGAMEPADCONTROL.input.buttons[1] != null) && _VGAMEPADCONTROL.input.buttons[1])) {
        PADBUTTONS[0][1] = true;
      } else if (_GAMEPADSINFO[0] == null) {
        PADBUTTONS[0][1] = false;
      }
      if (key.getKey("c") || ((_VGAMEPADCONTROL.input.buttons[2] != null) && _VGAMEPADCONTROL.input.buttons[2])) {
        PADBUTTONS[0][2] = true;
      } else if (_GAMEPADSINFO[0] == null) {
        PADBUTTONS[0][2] = false;
      }
      if (key.getKey("v") || ((_VGAMEPADCONTROL.input.buttons[3] != null) && _VGAMEPADCONTROL.input.buttons[3])) {
        PADBUTTONS[0][3] = true;
      } else if (_GAMEPADSINFO[0] == null) {
        PADBUTTONS[0][3] = false;
      }
      if (key.getKey("b") || ((_VGAMEPADCONTROL.input.buttons[4] != null) && _VGAMEPADCONTROL.input.buttons[4])) {
        PADBUTTONS[0][4] = true;
      } else if (_GAMEPADSINFO[0] == null) {
        PADBUTTONS[0][4] = false;
      }
      if (key.getKey("n") || ((_VGAMEPADCONTROL.input.buttons[5] != null) && _VGAMEPADCONTROL.input.buttons[5])) {
        PADBUTTONS[0][5] = true;
      } else if (_GAMEPADSINFO[0] == null) {
        PADBUTTONS[0][5] = false;
      }
      if (key.getKey("left") || ((_VGAMEPADCONTROL != null) && _VGAMEPADCONTROL.input.axes.left)) {
        PADAXES[0][HORIZONTAL] = -1;
      } else if (key.getKey("right") || ((_VGAMEPADCONTROL != null) && _VGAMEPADCONTROL.input.axes.right)) {
        PADAXES[0][HORIZONTAL] = 1;
      } else if (_GAMEPADSINFO[0] == null) {
        PADAXES[0][HORIZONTAL] = 0;
      }
      if (key.getKey("up") || ((_VGAMEPADCONTROL != null) && _VGAMEPADCONTROL.input.axes.up)) {
        PADAXES[0][VERTICAL] = -1;
      } else if (key.getKey("down") || ((_VGAMEPADCONTROL != null) && _VGAMEPADCONTROL.input.axes.down)) {
        PADAXES[0][VERTICAL] = 1;
      } else if (_GAMEPADSINFO[0] == null) {
        PADAXES[0][VERTICAL] = 0;
      }
      LAPSEDTIME = parseFloat((new Date) / 1000) - parseFloat(BEGINNINGTIME).toFixed(2);
      _results = [];
      for (_j = 0, _len = _objects.length; _j < _len; _j++) {
        obj = _objects[_j];
        if (obj.active === true && obj.motionObj !== void 0 && typeof obj.motionObj.behavior === 'function') {
          _results.push(obj.motionObj.behavior());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  });
  core = tm.app.CanvasApp("#stage");
  core.fps = FPS;
  core.resize(SCREEN_WIDTH, SCREEN_HEIGHT);
  core.fitWindow();
  MEDIALIST['_notice'] = 'lib/notice.png';
  MEDIALIST['_execbutton'] = 'lib/execbutton.png';
  MEDIALIST['_pad_w'] = 'lib/pad_w.png';
  MEDIALIST['_pad_b'] = 'lib/pad_b.png';
  MEDIALIST['_apad_w'] = 'lib/apad_w.png';
  MEDIALIST['_apad_b'] = 'lib/apad_b.png';
  MEDIALIST['_apad2_w'] = 'lib/apad2_w.png';
  MEDIALIST['_apad2_b'] = 'lib/apad2_b.png';
  MEDIALIST['_button_w'] = 'lib/button_w.png';
  MEDIALIST['_button_b'] = 'lib/button_b.png';
  core.replaceScene(customLoadingScene({
    assets: MEDIALIST,
    nextScene: mainScene,
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT
  }));
  core.run();
  window.addEventListener('devicemotion', function(e) {
    MOTION_ACCEL = e.acceleration;
    return MOTION_GRAVITY = e.accelerationIncludingGravity;
  });
  return window.addEventListener('deviceorientation', function(e) {
    MOTION_ROTATE.alpha = e.alpha;
    MOTION_ROTATE.beta = e.beta;
    return MOTION_ROTATE.gamma = e.gamma;
  });
});

debugwrite = function(param) {
  var fontcolor, fontsize, labeltext;
  if (DEBUG === true) {
    if (param.clear) {
      labeltext = (param.labeltext != null) ? param.labeltext : "";
    } else {
      labeltext = _DEBUGLABEL.text += (param.labeltext != null) ? param.labeltext : "";
    }
    fontsize = (param.fontsize != null) ? param.fontsize : 12;
    fontcolor = (param.fontcolor != null) ? param.fontcolor : "red";
    _DEBUGLABEL.fontSize = fontsize;
    _DEBUGLABEL.text = labeltext;
    return _DEBUGLABEL.fillStyle = fontcolor;
  }
};

debugclear = function() {
  if (DEBUG === true) {
    return _DEBUGLABEL.text = "";
  }
};

addObject = function(param, parent) {
  var active, animlist, animnum, animtmp, bgcolor, collider, color, density, depth, fontsize, friction, gravity, height, hlength, image, imagefile, img, kind, labeltext, map, mapcollision, mapdata, mapsheet, model, motionObj, motionsprite, offsetx, offsety, opacity, radius, radius2, restitution, retObject, rigid, rotation, scaleX, scaleY, scaleZ, scene, size, t, t2, textalign, texture, tx, visible, width, wlength, x, xs, y, ys, z, zs, _i, _j, _len, _len1, _type;
  if (parent == null) {
    parent = void 0;
  }
  motionObj = (param['motionObj'] != null) ? param['motionObj'] : void 0;
  _type = (param['type'] != null) ? param['type'] : SPRITE;
  x = (param['x'] != null) ? param['x'] : 0.0;
  y = (param['y'] != null) ? param['y'] : 0.0;
  z = (param['z'] != null) ? param['z'] : 0.0;
  xs = (param['xs'] != null) ? param['xs'] : 0.0;
  ys = (param['ys'] != null) ? param['ys'] : 0.0;
  zs = (param['zs'] != null) ? param['zs'] : 0.0;
  gravity = (param['gravity'] != null) ? param['gravity'] : 0.0;
  image = (param['image'] != null) ? param['image'] : void 0;
  model = (param['model'] != null) ? param['model'] : void 0;
  width = (param['width'] != null) ? param['width'] : 100.0;
  height = (param['height'] != null) ? param['height'] : 100.0;
  depth = (param['depth'] != null) ? param['depth'] : 100.0;
  opacity = (param['opacity'] != null) ? param['opacity'] : 1.0;
  animlist = (param['animlist'] != null) ? param['animlist'] : void 0;
  animnum = (param['animnum'] != null) ? param['animnum'] : 0;
  visible = (param['visible'] != null) ? param['visible'] : true;
  scene = (param['scene'] != null) ? param['scene'] : -1;
  rigid = (param['rigid'] != null) ? param['rigid'] : false;
  model = (param['model'] != null) ? param['model'] : void 0;
  density = (param['density'] != null) ? param['density'] : 1.0;
  friction = (param['friction'] != null) ? param['friction'] : 0.5;
  restitution = (param['restitution'] != null) ? param['restitution'] : 0.1;
  radius = (param['radius'] != null) ? param['radius'] : 100.0;
  radius2 = (param['radius2'] != null) ? param['radius2'] : 100.0;
  size = (param['size'] != null) ? param['size'] : 100.0;
  scaleX = (param['scaleX'] != null) ? param['scaleX'] : 1.0;
  scaleY = (param['scaleY'] != null) ? param['scaleY'] : 1.0;
  scaleZ = (param['scaleZ'] != null) ? param['scaleZ'] : 1.0;
  rotation = (param['rotation'] != null) ? param['rotation'] : 0.0;
  texture = (param['texture'] != null) ? param['texture'] : void 0;
  fontsize = (param['fontsize'] != null) ? param['fontsize'] : '16px';
  color = (param['color'] != null) ? param['color'] : 'white';
  labeltext = (param['labeltext'] != null) ? param['labeltext'].replace(/<br>/ig, "\\n") : 'text';
  textalign = (param['textalign'] != null) ? param['textalign'] : 'left';
  active = (param['active'] != null) ? param['active'] : true;
  kind = (param['kind'] != null) ? param['kind'] : DYNAMIC_BOX;
  collider = (param['collider'] != null) ? param['collider'] : void 0;
  offsetx = (param['offsetx'] != null) ? param['offsetx'] : 0;
  offsety = (param['offsety'] != null) ? param['offsety'] : 0;
  bgcolor = (param['bgcolor'] != null) ? param['bgcolor'] : 'transparent';
  map = (param['map'] != null) ? param['map'] : void 0;
  mapcollision = (param['mapcollision'] != null) ? param['mapcollision'] : void 0;
  if (motionObj === null) {
    motionObj = void 0;
  }
  retObject = void 0;
  switch (_type) {
    case CONTROL:
    case SPRITE:
      if (scene < 0) {
        scene = GAMESCENE_SUB1;
      }
      if ((animlist != null)) {
        if (rigid) {
          if (radius == null) {
            radius = width;
          }
        }
        if (typeof motionsprite === "undefined" || motionsprite === null) {
          motionsprite = tm.display.Sprite(image, width, height);
        }
        animtmp = animlist[animnum];
        motionsprite.frameIndex = animtmp[1][0];
        motionsprite.backgroundColor = "transparent";
        motionsprite.setOrigin(0.5, 0.5);
        motionsprite.x = Math.floor(x);
        motionsprite.y = Math.floor(y) - Math.floor(z);
        motionsprite.alpha = opacity;
        motionsprite.rotation = rotation;
        motionsprite.scaleX = scaleX;
        motionsprite.scaleY = scaleY;
        motionsprite.visible = visible;
        motionsprite.width = width;
        motionsprite.height = height;
        motionsprite.boundingType = "rect";
      } else {
        motionsprite = tm.display.Sprite();
      }
      motionsprite.addChildTo(_scenes[scene]);
      retObject = this.setMotionObj({
        x: x,
        y: y,
        z: z,
        xs: xs,
        ys: ys,
        zs: zs,
        visible: visible,
        scaleX: scaleX,
        scaleY: scaleY,
        scaleZ: scaleZ,
        gravity: gravity,
        width: width,
        height: height,
        animlist: animlist,
        animnum: animnum,
        opacity: opacity,
        scene: scene,
        image: image,
        _type: _type,
        motionsprite: motionsprite,
        motionObj: motionObj,
        rotation: rotation,
        parent: parent,
        active: active,
        collider: collider,
        offsetx: offsetx,
        offsety: offsety
      });
      return retObject;
    case LABEL:
      if (scene < 0) {
        scene = GAMESCENE_SUB1;
      }
      if (width === 0) {
        width = 120;
      }
      if (height === 0) {
        height = 64;
      }
      motionsprite = tm.display.Label(labeltext);
      motionsprite.setOrigin(0.5, 0.5);
      motionsprite.setPosition(x, y);
      motionsprite.x = Math.floor(x);
      motionsprite.y = Math.floor(y) - Math.floor(z);
      motionsprite.alpha = opacity;
      motionsprite.rotation = rotation;
      motionsprite.scaleX = scaleX;
      motionsprite.scaleY = scaleY;
      motionsprite.visible = visible;
      motionsprite.width = width;
      motionsprite.height = height;
      motionsprite.fillStyle = color;
      motionsprite.text = labeltext;
      motionsprite.fontSize = fontsize;
      motionsprite.align = textalign;
      motionsprite.fontFamily = 'Arial';
      motionsprite.setBaseline("middle");
      motionsprite.addChildTo(_scenes[scene]);
      retObject = this.setMotionObj({
        x: x,
        y: y,
        z: z,
        xs: xs,
        ys: ys,
        zs: zs,
        visible: visible,
        scaleX: scaleX,
        scaleY: scaleY,
        scaleZ: scaleZ,
        width: width,
        height: height,
        opacity: opacity,
        scene: scene,
        image: image,
        _type: _type,
        motionsprite: motionsprite,
        motionObj: motionObj,
        fontsize: fontsize,
        color: color,
        labeltext: labeltext,
        textalign: textalign,
        parent: parent,
        active: active,
        collider: collider,
        offsetx: offsetx,
        offsety: offsety
      });
      return retObject;
    case PRIMITIVE:
      switch (model) {
        case BOX:
          motionsprite = new Box(width, height, depth);
          break;
        case CUBE:
          motionsprite = new Cube(size);
          break;
        case SPHERE:
          motionsprite = new Sphere(size);
          break;
        case CYLINDER:
          motionsprite = new Cylinder(radius, height);
          break;
        case TORUS:
          motionsprite = new Torus(radius, radius2);
          break;
        case PLANE:
          motionsprite = new Plane(size);
          break;
        default:
          return void 0;
      }
      if ((texture != null)) {
        imagefile = MEDIALIST[texture];
        tx = new Texture(imagefile);
        motionsprite.mesh.texture = tx;
      }
      retObject = this.setMotionObj({
        x: x,
        y: y,
        z: z,
        xs: xs,
        ys: ys,
        zs: zs,
        visible: visible,
        scaleX: scaleX,
        scaleY: scaleY,
        scaleZ: scaleZ,
        radius: radius,
        radius2: radius2,
        size: size,
        gravity: gravity,
        width: width,
        height: height,
        depth: depth,
        animlist: animlist,
        animnum: animnum,
        opacity: opacity,
        scene: WEBGLSCENE,
        _type: _type,
        motionsprite: motionsprite,
        motionObj: motionObj,
        parent: parent
      });
      if (visible) {
        rootScene3d.addChild(motionsprite);
      }
      return retObject;
    case COLLADA:
      if ((MEDIALIST[model] != null)) {
        motionsprite = new Sprite3D();
        motionsprite.set(core.assets[MEDIALIST[model]].clone());
      } else {
        return void 0;
      }
      if (visible) {
        rootScene3d.addChild(motionsprite);
      }
      retObject = this.setMotionObj({
        x: x,
        y: y,
        z: z,
        xs: xs,
        ys: ys,
        zs: zs,
        visible: visible,
        scaleX: scaleX,
        scaleY: scaleY,
        scaleZ: scaleZ,
        radius: radius,
        radius2: radius2,
        size: size,
        gravity: gravity,
        width: width,
        height: height,
        depth: depth,
        animlist: animlist,
        animnum: animnum,
        opacity: opacity,
        scene: WEBGLSCENE,
        _type: _type,
        motionsprite: motionsprite,
        motionObj: motionObj,
        parent: parent
      });
      return retObject;
    case MAP:
      if ((map == null) || image === "") {
        JSLog("parameter not enough.");
      } else {
        if (scene < 0) {
          scene = BGSCENE_SUB1;
        }
        img = MEDIALIST[image];
        mapdata = [];
        wlength = map[0].length;
        hlength = map.length;
        for (_i = 0, _len = map.length; _i < _len; _i++) {
          t = map[_i];
          for (_j = 0, _len1 = t.length; _j < _len1; _j++) {
            t2 = t[_j];
            mapdata.push(t2);
          }
        }
        mapsheet = tm.asset.MapSheet({
          tilewidth: width,
          tileheight: height,
          width: wlength,
          height: hlength,
          tilesets: [
            {
              image: img
            }
          ],
          layers: [
            {
              data: mapdata
            }
          ]
        });
        motionsprite = tm.display.MapSprite(mapsheet, width, height);
        _scenes[scene].addChild(motionsprite);
      }
      retObject = this.setMotionObj({
        x: x,
        y: y,
        xs: xs,
        ys: ys,
        map: map,
        visible: visible,
        width: width,
        height: height,
        opacity: opacity,
        scene: scene,
        image: image,
        _type: _type,
        motionsprite: motionsprite,
        motionObj: motionObj,
        parent: parent
      });
      return retObject;
  }
};

setMotionObj = function(param) {
  var initparam, map, mapheight, mapwidth, motionObj, obj, objnum, scene, uid, _type;
  initparam = [];
  initparam['x'] = (param['x'] != null) ? param['x'] : 0;
  initparam['y'] = (param['y'] != null) ? param['y'] : 0;
  initparam['z'] = (param['z'] != null) ? param['z'] : 0;
  initparam['xs'] = (param['xs'] != null) ? param['xs'] : 0;
  initparam['ys'] = (param['ys'] != null) ? param['ys'] : 0;
  initparam['zs'] = (param['zs'] != null) ? param['zs'] : 0;
  initparam['visible'] = (param['visible'] != null) ? param['visible'] : true;
  initparam['scaleX'] = (param['scaleX'] != null) ? param['scaleX'] : 1.0;
  initparam['scaleY'] = (param['scaleY'] != null) ? param['scaleY'] : 1.0;
  initparam['scaleZ'] = (param['scaleZ'] != null) ? param['scaleZ'] : 1.0;
  initparam['radius'] = (param['radius'] != null) ? param['radius'] : 1.0;
  initparam['radius2'] = (param['radius2'] != null) ? param['radius2'] : 1.0;
  initparam['size'] = (param['size'] != null) ? param['size'] : 1.0;
  initparam['gravity'] = (param['gravity'] != null) ? param['gravity'] : 0;
  initparam['intersectFlag'] = (param['intersectFlag'] != null) ? param['intersectFlag'] : true;
  initparam['width'] = (param['width'] != null) ? param['width'] : 0;
  initparam['height'] = (param['height'] != null) ? param['height'] : 0;
  initparam['animlist'] = (param['animlist'] != null) ? param['animlist'] : 0;
  initparam['animnum'] = (param['animnum'] != null) ? param['animnum'] : 0;
  initparam['visible'] = (param['visible'] != null) ? param['visible'] : true;
  initparam['opacity'] = (param['opacity'] != null) ? param['opacity'] : 0;
  initparam['rotation'] = (param['rotation'] != null) ? param['rotation'] : 0.0;
  initparam['motionsprite'] = (param['motionsprite'] != null) ? param['motionsprite'] : 0;
  initparam['fontsize'] = (param['fontsize'] != null) ? param['fontsize'] : '16px';
  initparam['color'] = (param['color'] != null) ? param['color'] : 'white';
  initparam['labeltext'] = (param['labeltext'] != null) ? param['labeltext'] : 'text';
  initparam['textalign'] = (param['textalign'] != null) ? param['textalign'] : 'left';
  initparam['parent'] = (param['parent'] != null) ? param['parent'] : void 0;
  initparam['active'] = (param['active'] != null) ? param['active'] : true;
  initparam['collider'] = (param['collider'] != null) ? param['collider'] : void 0;
  initparam['offsetx'] = (param['offsetx'] != null) ? param['offsetx'] : 0;
  initparam['offsety'] = (param['offsety'] != null) ? param['offsety'] : 0;
  scene = (param['scene'] != null) ? param['scene'] : GAMESCENE;
  _type = (param['_type'] != null) ? param['_type'] : SPRITE;
  initparam['_type'] = _type;
  motionObj = (param['motionObj'] != null) ? param['motionObj'] : void 0;
  map = (param['map'] != null) ? param['map'] : [];
  if (_type === MAP || _type === EXMAP) {
    mapwidth = map[0].length * initparam['width'];
    mapheight = map.length * initparam['height'];
    initparam['diffx'] = Math.floor(mapwidth / 2);
    initparam['diffy'] = Math.floor(mapheight / 2);
  } else {
    initparam['diffx'] = Math.floor(initparam['width'] / 2);
    initparam['diffy'] = Math.floor(initparam['height'] / 2);
  }
  objnum = _getNullObject();
  if (objnum < 0) {
    return void 0;
  }
  obj = _objects[objnum];
  obj.active = true;
  if ((motionObj != null)) {
    obj.motionObj = new motionObj(initparam);
  } else {
    obj.motionObj = new _stationary(initparam);
  }
  uid = uniqueID();
  obj.motionObj._uniqueID = uid;
  obj.motionObj._scene = scene;
  obj.motionObj._type = _type;
  return obj.motionObj;
};

removeObject = function(motionObj) {
  var object, ret, _i, _len;
  if (motionObj == null) {
    return;
  }
  ret = false;
  for (_i = 0, _len = _objects.length; _i < _len; _i++) {
    object = _objects[_i];
    if (object.motionObj == null) {
      continue;
    }
    if (object.motionObj._uniqueID === motionObj._uniqueID) {
      ret = true;
      break;
    }
  }
  if (ret === false) {
    return;
  }
  if (motionObj.collider._uniqueID !== motionObj._uniqueID) {
    removeObject(motionObj.collider);
  }
  if (typeof motionObj.destructor === 'function') {
    motionObj.destructor();
  }
  if (motionObj.rigid) {
    nop();
  } else {
    switch (motionObj._type) {
      case CONTROL:
      case SPRITE:
      case LABEL:
      case PRIMITIVE:
      case COLLADA:
      case MAP:
      case EXMAP:
        _scenes[object.motionObj._scene].removeChild(object.motionObj.sprite);
    }
  }
  object.motionObj.sprite = void 0;
  object.motionObj = void 0;
  return object.active = false;
};

getObject = function(id) {
  var i, ret, _i, _ref;
  ret = void 0;
  for (i = _i = 0, _ref = _objects.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (_objects[i] == null) {
      continue;
    }
    if (_objects[i].motionObj == null) {
      continue;
    }
    if (_objects[i].motionObj._uniqueID === id) {
      ret = _objects[i].motionObj;
      break;
    }
  }
  return ret;
};

playSound = function(name, vol, flag) {
  var org, sound;
  if (vol == null) {
    vol = 1.0;
  }
  if (flag == null) {
    flag = false;
  }
  org = tm.asset.Manager.get(name);
  sound = org.clone();
  if ((sound.loop != null)) {
    sound.volume = vol;
    sound.play();
    sound.loop = flag;
    return sound;
  }
};

pauseSound = function(obj) {
  return obj.pause();
};

resumeSound = function(obj, flag) {
  if (flag == null) {
    flag = false;
  }
  obj.play();
  return obj.loop = flag;
};

stopSound = function(obj) {
  return obj.stop();
};

setSoundLoudness = function(obj, num) {
  return obj.volume = num;
};

pauseGame = function() {
  ACTIVATE = false;
  return core.pause();
};

resumeGame = function() {
  ACTIVATE = true;
  return core.resume();
};

createVirtualGamepad = function(param) {
  var analog, button, buttonscale, coord, kind, scale, visible, x, y;
  if ((param != null)) {
    scale = (param.scale != null) ? param.scale : 1;
    x = (param.x != null) ? param.x : (100 / 2) * scale;
    y = (param.y != null) ? param.y : SCREEN_HEIGHT - ((100 / 2) * scale);
    visible = (param.visible != null) ? param.visible : true;
    kind = (param.kind != null) ? param.kind : 0;
    analog = (param.analog != null) ? param.analog : false;
    button = (param.button != null) ? param.button : 0;
    buttonscale = (param.buttonscale != null) ? param.buttonscale : 1;
    coord = (param.coord != null) ? param.coord : [];
  } else {
    param = [];
    scale = param.scale = 1.0;
    x = param.x = (100 / 2) * scale;
    y = param.y = SCREEN_HEIGHT - ((100 / 2) * scale);
    visible = param.visible = true;
    kind = param.kind = 0;
    analog = param.analog = false;
    button = param.button = 0;
    buttonscale = param.buttonscale = 1;
    coord = param.coord = [];
  }
  if (button > 6) {
    button = param.button = 6;
  }
  if (_VGAMEPADCONTROL == null) {
    _VGAMEPADCONTROL = addObject({
      x: x,
      y: y,
      type: CONTROL,
      motionObj: _vgamepadcontrol
    });
    return _VGAMEPADCONTROL.createGamePad(param);
  }
};

dispVirtualGamepad = function(flag) {
  return _VGAMEPADCONTROL.setVisible(flag);
};

gamepaddisconnected = function(e) {};

_getNullObject = function() {
  var i, ret, _i, _ref;
  ret = -1;
  for (i = _i = 0, _ref = _objects.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (_objects[i].active === false) {
      ret = i;
      break;
    }
  }
  return ret;
};

dispDefaultBrowserCheck = function(func) {
  var caution, cautionscale, okbutton,
    _this = this;
  if (_defaultbrowser) {
    cautionscale = SCREEN_WIDTH / 320;
    caution = addObject({
      image: '_notice',
      x: SCREEN_WIDTH / 2,
      y: 200,
      width: 300,
      height: 140,
      animlist: [[100, [0]]],
      scaleX: cautionscale,
      scaleY: cautionscale
    });
    okbutton = addObject({
      image: '_execbutton',
      x: SCREEN_WIDTH / 2,
      y: 320,
      width: 80,
      height: 32,
      animlist: [[100, [0]]],
      scaleX: cautionscale,
      scaleY: cautionscale
    });
    return okbutton.sprite.ontouchstart = function(e) {
      removeObject(caution);
      removeObject(okbutton);
      return func();
    };
  } else {
    return func();
  }
};

_GAMEPADPROCEDURE_ = [];

_GAMEPADPROCEDURE_['firefox_gamepad'] = function(gamepadsinfo) {
  var analogstick, axes, bt, btnum, buttons, gamepad, id, index, max, padaxes, padbuttons, padnum, padresult, _i, _j, _ref;
  padresult = [];
  for (padnum = _i = 0, _ref = gamepadsinfo.length; 0 <= _ref ? _i < _ref : _i > _ref; padnum = 0 <= _ref ? ++_i : --_i) {
    gamepad = gamepadsinfo[padnum];
    if (gamepad == null) {
      continue;
    }
    buttons = gamepad.buttons;
    axes = gamepad.axes;
    index = gamepad.index;
    id = gamepad.id;
    max = (buttons.length < 6 ? buttons.length : 6);
    padbuttons = [];
    for (btnum = _j = 0; 0 <= max ? _j < max : _j > max; btnum = 0 <= max ? ++_j : --_j) {
      bt = buttons[btnum];
      padbuttons[btnum] = bt.pressed;
    }
    if (id.match(/.*45e.*?28e.*/)) {
      padbuttons[6] = buttons[9].pressed;
      padbuttons[7] = buttons[8].pressed;
    } else {
      padbuttons[6] = buttons[6].pressed;
      padbuttons[7] = buttons[7].pressed;
    }
    analogstick = [];
    analogstick[0] = [gamepad.axes[0], gamepad.axes[1]];
    analogstick[1] = [gamepad.axes[2], gamepad.axes[3]];
    padaxes = [];
    if (((gamepad.buttons[13] != null) && gamepad.buttons[13].pressed) || gamepad.axes[0].pressed || parseInt(gamepad.axes[0]) < 0) {
      padaxes[0] = -1;
    } else if (((gamepad.buttons[14] != null) && gamepad.buttons[14].pressed) || gamepad.axes[0].pressed || parseInt(gamepad.axes[0]) > 0) {
      padaxes[0] = 1;
    } else {
      padaxes[0] = 0;
    }
    if (((gamepad.buttons[11] != null) && gamepad.buttons[11].pressed) || gamepad.axes[1].pressed || parseInt(gamepad.axes[1]) < 0) {
      padaxes[1] = -1;
    } else if (((gamepad.buttons[12] != null) && gamepad.buttons[12].pressed) || gamepad.axes[1].pressed || parseInt(gamepad.axes[1]) > 0) {
      padaxes[1] = 1;
    } else {
      padaxes[1] = 0;
    }
    padresult[index] = [];
    padresult[index].id = id;
    padresult[index].padbuttons = padbuttons;
    padresult[index].padaxes = padaxes;
    padresult[index].analogstick = analogstick;
  }
  return padresult;
};

_GAMEPADPROCEDURE_['chrome_gamepad'] = function(gamepadsinfo) {
  var analogstick, axes, bt, btnum, buttons, gamepad, id, index, max, padaxes, padbuttons, padnum, padresult, _i, _j, _ref;
  padresult = [];
  for (padnum = _i = 0, _ref = gamepadsinfo.length; 0 <= _ref ? _i < _ref : _i > _ref; padnum = 0 <= _ref ? ++_i : --_i) {
    gamepad = gamepadsinfo[padnum];
    if (gamepad == null) {
      continue;
    }
    buttons = gamepad.buttons;
    axes = gamepad.axes;
    index = gamepad.index;
    id = gamepad.id;
    max = (buttons.length < 6 ? buttons.length : 6);
    padbuttons = [];
    for (btnum = _j = 0; 0 <= max ? _j < max : _j > max; btnum = 0 <= max ? ++_j : --_j) {
      bt = buttons[btnum];
      padbuttons[btnum] = bt.pressed;
    }
    if (id.match(/.*45e.*?28e.*/)) {
      padbuttons[6] = buttons[8].pressed;
      padbuttons[7] = buttons[9].pressed;
    } else {
      padbuttons[6] = buttons[6].pressed;
      padbuttons[7] = buttons[7].pressed;
    }
    analogstick = [];
    analogstick[0] = [gamepad.axes[0], gamepad.axes[1]];
    analogstick[1] = [gamepad.axes[2], gamepad.axes[3]];
    padaxes = [];
    if (((gamepad.buttons[14] != null) && gamepad.buttons[14].pressed) || gamepad.axes[0].pressed || parseInt(gamepad.axes[0]) < 0) {
      padaxes[0] = -1;
    } else if (((gamepad.buttons[15] != null) && gamepad.buttons[15].pressed) || gamepad.axes[0].pressed || parseInt(gamepad.axes[0]) > 0) {
      padaxes[0] = 1;
    } else {
      padaxes[0] = 0;
    }
    if (((gamepad.buttons[12] != null) && gamepad.buttons[12].pressed) || gamepad.axes[1].pressed || parseInt(gamepad.axes[1]) < 0) {
      padaxes[1] = -1;
    } else if (((gamepad.buttons[13] != null) && gamepad.buttons[13].pressed) || gamepad.axes[1].pressed || parseInt(gamepad.axes[1]) > 0) {
      padaxes[1] = 1;
    } else {
      padaxes[1] = 0;
    }
    padresult[index] = [];
    padresult[index].id = id;
    padresult[index].padbuttons = padbuttons;
    padresult[index].padaxes = padaxes;
    padresult[index].analogstick = analogstick;
  }
  return padresult;
};

gamepadProcedure = function() {
  var browserGamepadFunctionName, gamepadsinfo, padresult, _ua;
  _ua = window.navigator.userAgent.toLowerCase();
  if (_ua.match(/.* firefox\/.*/)) {
    _browserMajorClass = "firefox";
  } else if (_ua.match(/.*version\/.* safari\/.*/)) {
    _browserMajorClass = "safari";
  } else if (_ua.match(/.*chrome\/.* safari\/.*/)) {
    _browserMajorClass = "chrome";
  } else {
    _browserMajorClass = "unknown";
  }
  padresult = [];
  browserGamepadFunctionName = _browserMajorClass + "_gamepad";
  if (typeof _GAMEPADPROCEDURE_[browserGamepadFunctionName] === 'function') {
    gamepadsinfo = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
    if ((gamepadsinfo != null) && gamepadsinfo.length > 0) {
      padresult = _GAMEPADPROCEDURE_[browserGamepadFunctionName](gamepadsinfo);
    }
  }
  return padresult;
};
