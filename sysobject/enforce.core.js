// Generated by CoffeeScript 1.3.3
var BGSCENE, BGSCENE_SUB1, BGSCENE_SUB2, CONTROL, GAMESCENE, GAMESCENE_SUB1, GAMESCENE_SUB2, JSLog, LABEL, PHYSICS, SPRITE, TOPSCENE, WEBGL, core, createObject, debugwrite, lapsedtime, rand, removeObject, rootScene, sprintf, _DEBUGLABEL, _getNullObject, _main, _objects, _originObject, _scenes, _stationary,
  __slice = [].slice;

_originObject = (function() {

  function _originObject() {
    this.active = false;
  }

  return _originObject;

})();

_stationary = (function() {

  function _stationary(sprite) {
    var _this = this;
    this.sprite = sprite;
    this._processnumber = 0;
    this._waittime = 0.0;
    this._dispframe = 0;
    this._endflag = false;
    if ((this.sprite != null)) {
      this.sprite.intersectFlag = true;
      this.sprite.addEventListener('touchstart', function(e) {
        if (typeof _this.touchesBegan === 'function') {
          return _this.touchesBegan(e);
        }
      });
      this.sprite.addEventListener('touchmove', function(e) {
        if (typeof _this.touchesMoved === 'function') {
          return _this.touchesMoved(e);
        }
      });
      this.sprite.addEventListener('touchend', function(e) {
        if (typeof _this.touchesEnded === 'function') {
          return _this.touchesEnded(e);
        }
      });
      this.sprite.addEventListener('touchcancel', function(e) {
        if (typeof _this.touchesCanceled === 'function') {
          return _this.touchesCanceled(e);
        }
      });
    }
  }

  _stationary.prototype.destructor = function() {};

  _stationary.prototype.behavior = function() {
    var animpattern;
    if (this._type_ === SPRITE) {
      if (this.sprite.x !== this.sprite.xback) {
        this.sprite.x2 = this.sprite.x;
      }
      if (this.sprite.y !== this.sprite.yback) {
        this.sprite.y2 = this.sprite.y;
      }
      this.sprite.ys += this.sprite.gravity;
      this.sprite.x2 += this.sprite.xs;
      this.sprite.y2 += this.sprite.ys;
      this.sprite.x = Math.round(this.sprite.x2);
      this.sprite.y = Math.round(this.sprite.y2);
      this.sprite.xback = this.sprite.x;
      this.sprite.yback = this.sprite.y;
    }
    if ((this.sprite.animlist != null)) {
      animpattern = this.sprite.animlist[this.sprite.animnum];
      this.sprite.frame = animpattern[this._dispframe++];
      if (this._dispframe >= animpattern.length) {
        if (this._endflag === false) {
          this._dispframe = 0;
        } else {
          removeObject(this);
          return;
        }
      }
    }
    if (this._waittime > 0 && lapsedtime > this._waittime) {
      this._waittime = 0;
      return this._processnumber = this._nextprocessnum;
    }
  };

  _stationary.prototype.touchesBegan = function(e) {};

  _stationary.prototype.touchesMoved = function(e) {};

  _stationary.prototype.touchesEnded = function(e) {};

  _stationary.prototype.touchesCanceled = function(e) {};

  _stationary.prototype.nextjob = function() {
    return this._processnumber++;
  };

  _stationary.prototype.waitjob = function(wtime) {
    this._waittime = lapsedtime + wtime;
    this._nextprocessnum = this._processnumber + 1;
    return this._processnumber = -1;
  };

  _stationary.prototype.setProcessNumber = function(num) {
    return this._processnumber = num;
  };

  _stationary.prototype.isWithIn = function(sprite, range) {
    var ret;
    if (range == null) {
      range = -1;
    }
    if (!(this.sprite != null) || !(sprite != null)) {
      reuturn(false);
    }
    if (range < 0) {
      range = sprite.width / 2;
    }
    if (this.sprite.intersectFlag === true && sprite.intersectFlag === true) {
      ret = this.sprite.within(sprite, range);
    } else {
      ret = false;
    }
    return ret;
  };

  _stationary.prototype.isIntersect = function(sprite) {
    var ret;
    if (!(this.sprite != null) || !(sprite != null)) {
      reuturn(false);
    }
    if (this.sprite.intersectFlag === true && sprite.intersectFlag === true) {
      ret = this.sprite.intersect(sprite);
    } else {
      ret = false;
    }
    return ret;
  };

  _stationary.prototype.setAnimationToRemove = function(animnum) {
    this.sprite.animnum = animnum;
    this._dispframe = 0;
    return this._endflag = true;
  };

  _stationary.prototype.nop = function() {};

  return _stationary;

})();

rand = function(n) {
  return Math.floor(Math.random() * (n + 1));
};

JSLog = function() {
  var a, b, data, _i, _len;
  a = arguments[0], b = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (DEBUG === true) {
    for (_i = 0, _len = b.length; _i < _len; _i++) {
      data = b[_i];
      a = a.replace('%@', data);
    }
    return console.log(a);
  }
};

sprintf = function() {
  var a, b, data, _i, _len;
  a = arguments[0], b = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = b.length; _i < _len; _i++) {
    data = b[_i];
    a = a.replace('%@', data);
  }
  return a;
};

CONTROL = 0;

SPRITE = 1;

LABEL = 2;

PHYSICS = 3;

WEBGL = 4;

BGSCENE = 0;

BGSCENE_SUB1 = 1;

BGSCENE_SUB2 = 2;

GAMESCENE = 3;

GAMESCENE_SUB1 = 4;

GAMESCENE_SUB2 = 5;

TOPSCENE = 6;

_objects = [];

_scenes = [];

_main = null;

_DEBUGLABEL = null;

core = null;

rootScene = null;

lapsedtime = 0;

enchant();

window.onload = function() {
  var i, scene, _i, _ref;
  core = new Core(SCREEN_WIDTH, SCREEN_HEIGHT);
  rootScene = core.rootScene;
  core.rootScene.backgroundColor = BGCOLOR;
  core.fps = FPS;
  core.preload(IMAGELIST);
  for (i = _i = 0, _ref = TOPSCENE + 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    scene = new Group();
    _scenes[i] = scene;
    core.rootScene.addChild(scene);
  }
  core.onload = function() {
    var _j;
    for (i = _j = 0; 0 <= OBJECTNUM ? _j < OBJECTNUM : _j > OBJECTNUM; i = 0 <= OBJECTNUM ? ++_j : --_j) {
      _objects[i] = new _originObject();
    }
    _main = new enchantMain();
    if (DEBUG === true) {
      _DEBUGLABEL = new Label();
      _DEBUGLABEL.x = 0;
      _DEBUGLABEL.y = 0;
      _DEBUGLABEL.color = "black";
      _DEBUGLABEL.font = "10px 'Arial'";
      _scenes[TOPSCENE].addChild(_DEBUGLABEL);
    }
    return core.rootScene.addEventListener('enterframe', function(e) {
      lapsedtime = core.frame / FPS;
      return lapsedtime = parseFloat(lapsedtime.toFixed(2));
    });
  };
  return core.start();
};

debugwrite = function(str) {
  if (DEBUG === true) {
    return _DEBUGLABEL.text = str;
  }
};

createObject = function(motionObj, _type_, x, y, xs, ys, g, image, cellx, celly, opacity, animlist, animnum, visible, scene) {
  var animpattern, motionsprite, obj;
  if (motionObj == null) {
    motionObj = void 0;
  }
  if (_type_ == null) {
    _type_ = SPRITE;
  }
  if (x == null) {
    x = 0;
  }
  if (y == null) {
    y = 0;
  }
  if (xs == null) {
    xs = 0.0;
  }
  if (ys == null) {
    ys = 0.0;
  }
  if (g == null) {
    g = 0.0;
  }
  if (image == null) {
    image = 0;
  }
  if (cellx == null) {
    cellx = 0;
  }
  if (celly == null) {
    celly = 0;
  }
  if (opacity == null) {
    opacity = 1.0;
  }
  if (animlist == null) {
    animlist = void 0;
  }
  if (animnum == null) {
    animnum = 0;
  }
  if (visible == null) {
    visible = true;
  }
  if (scene == null) {
    scene = GAMESCENE;
  }
  if (motionObj === null) {
    motionObj = void 0;
  }
  obj = _getNullObject();
  if (obj === void 0) {
    JSLog("object undefined");
    return void 0;
  }
  obj.active = true;
  switch (_type_) {
    case CONTROL:
    case SPRITE:
      motionsprite = new Sprite();
      break;
    case LABEL:
      motionsprite = new Label();
      break;
    default:
      motionsprite = new Sprite();
  }
  _scenes[scene].addChild(motionsprite);
  switch (_type_) {
    case SPRITE:
      motionsprite.frame = 0;
      motionsprite.backgroundColor = "transparent";
      motionsprite.x = x;
      motionsprite.y = y;
      motionsprite.x2 = x;
      motionsprite.y2 = y;
      motionsprite.width = cellx;
      motionsprite.height = celly;
      motionsprite.originX = cellx / 2;
      motionsprite.originY = celly / 2;
      motionsprite.opacity = opacity;
      motionsprite.rotation = 0.0;
      motionsprite.scaleX = 1.0;
      motionsprite.scaleY = 1.0;
      motionsprite.visible = visible;
      motionsprite.intersectFlag = true;
      motionsprite.animlist = animlist;
      motionsprite.animnum = animnum;
      motionsprite.xs = xs;
      motionsprite.ys = ys;
      motionsprite.gravity = g;
      break;
    case LABEL:
      motionsprite.x = x;
      motionsprite.y = y;
      motionsprite.x2 = x;
      motionsprite.y2 = y;
      motionsprite.textAlign = "left";
      motionsprite.font = "12pt 'Arial'";
      motionsprite.color = "black";
  }
  if (motionObj !== void 0) {
    obj.motionObj = new motionObj(motionsprite);
  } else {
    obj.motionObj = new _stationary(motionsprite);
  }
  obj.motionObj._objnum = obj._objnum;
  obj.motionObj._scene = scene;
  if (motionsprite !== void 0) {
    motionsprite.addEventListener('enterframe', function() {
      if (obj.motionObj !== void 0 && typeof obj.motionObj.behavior === 'function') {
        return obj.motionObj.behavior();
      }
    });
  }
  if ((IMAGELIST[image] != null) && (animlist != null)) {
    motionsprite.image = core.assets[IMAGELIST[image]];
  }
  if ((animlist != null)) {
    animpattern = animlist[animnum];
    motionsprite.frame = animpattern[0];
  }
  obj.motionObj._type_ = _type_;
  return obj.motionObj;
};

removeObject = function(obj) {
  var num, parent, scene;
  if (obj === void 0) {
    return;
  }
  num = obj._objnum;
  parent = _objects[num];
  scene = obj._scene;
  if (typeof obj.destructor === 'function') {
    obj.destructor();
  }
  if (scene !== void 0) {
    _scenes[scene].removeChild(obj.sprite);
  }
  obj.sprite = 0;
  parent.active = false;
  return parent.motionObj = void 0;
};

_getNullObject = function() {
  var i, obj, retobj, _i, _ref;
  retobj = void 0;
  for (i = _i = 0, _ref = _objects.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    obj = _objects[i];
    if (obj.active === false) {
      retobj = obj;
      retobj._objnum = i;
      break;
    }
  }
  return retobj;
};
